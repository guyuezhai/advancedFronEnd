const data=[
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/22",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/22/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/22/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/22/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/22",
    "id": 685195111,
    "node_id": "MDU6SXNzdWU2ODUxOTUxMTE=",
    "number": 22,
    "title": "react-router 的 <Link> 标签和 <a> 标签有什么区别",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-25T05:56:33Z",
    "updated_at": "2020-08-25T06:10:28Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "从最终渲染的DOM来看，这两者都是\\<a>标签，\r\n在react-router中\\<Link>标签需要配合\\<Route>标签做路由跳转，react-router接管了其默认的跳转行为，\r\n有别于传统的页面跳转，且\\<Link>的跳转只触发相匹配的\\<Route>对应页面内容更新，不会刷新整个页面。\r\n而\\<a>标签是普通的超链接，用于从当前页面跳转到href指向的另一个页面（非锚点情况）",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/21",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/21/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/21/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/21/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/21",
    "id": 684332667,
    "node_id": "MDU6SXNzdWU2ODQzMzI2Njc=",
    "number": 21,
    "title": " 两数之和",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2020-08-24T03:29:38Z",
    "updated_at": "2020-08-24T03:29:58Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\r\n\r\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\r\n\r\n示例:\r\n> 给定 nums = [2, 7, 11, 15], target = 9\r\n因为 nums[0] + nums[1] = 2 + 7 = 9\r\n所以返回 [0, 1]\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/20",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/20/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/20/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/20/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/20",
    "id": 684320300,
    "node_id": "MDU6SXNzdWU2ODQzMjAzMDA=",
    "number": 20,
    "title": "在输入框中如何判断输入的是一个正确的网址",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-24T02:46:09Z",
    "updated_at": "2020-08-24T02:46:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "```js\r\nconst isUrl = urlStr => {\r\n    try {\r\n        const { href, origin, host, hostname, pathname } = new URL(urlStr)\r\n        return href && origin && host && hostname && pathname && true\r\n    } catch (e) {\r\n        return false\r\n    }\r\n}\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/19",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/19/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/19/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/19/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/19",
    "id": 684308041,
    "node_id": "MDU6SXNzdWU2ODQzMDgwNDE=",
    "number": 19,
    "title": "实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2020-08-24T02:01:21Z",
    "updated_at": "2020-08-24T02:20:55Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：\r\n```js\r\n// 原始 list 如下\r\nlet list =[\r\n    {id:1,name:'部门A',parentId:0},\r\n    {id:2,name:'部门B',parentId:0},\r\n    {id:3,name:'部门C',parentId:1},\r\n    {id:4,name:'部门D',parentId:1},\r\n    {id:5,name:'部门E',parentId:2},\r\n    {id:6,name:'部门F',parentId:3},\r\n    {id:7,name:'部门G',parentId:2},\r\n    {id:8,name:'部门H',parentId:4}\r\n];\r\nconst result = convert(list, ...);\r\n\r\n// 转换后的结果如下\r\nlet result = [\r\n    {\r\n      id: 1,\r\n      name: '部门A',\r\n      parentId: 0,\r\n      children: [\r\n        {\r\n          id: 3,\r\n          name: '部门C',\r\n          parentId: 1,\r\n          children: [\r\n            {\r\n              id: 6,\r\n              name: '部门F',\r\n              parentId: 3\r\n            }, {\r\n              id: 16,\r\n              name: '部门L',\r\n              parentId: 3\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          id: 4,\r\n          name: '部门D',\r\n          parentId: 1,\r\n          children: [\r\n            {\r\n              id: 8,\r\n              name: '部门H',\r\n              parentId: 4\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    },\r\n  ···\r\n];\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/18",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/18/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/18/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/18/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/18",
    "id": 683520064,
    "node_id": "MDU6SXNzdWU2ODM1MjAwNjQ=",
    "number": 18,
    "title": "给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2020-08-21T12:17:43Z",
    "updated_at": "2020-08-21T12:23:25Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "示例 1：\r\n> nums1 = [1, 3]\r\nnums2 = [2]\r\n\r\n中位数是 2.0\r\n\r\n示例 2：\r\n\r\n> nums1 = [1, 2]\r\nnums2 = [3, 4]\r\n\r\n中位数是(2 + 3) / 2 = 2.5",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/17",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/17/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/17/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/17/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/17",
    "id": 683498701,
    "node_id": "MDU6SXNzdWU2ODM0OTg3MDE=",
    "number": 17,
    "title": "模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-21T11:35:55Z",
    "updated_at": "2020-08-21T11:35:55Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "```js\r\n\r\nvar testobj={\r\n    num: 0,\r\n    str: '',\r\n    boolean: true,\r\n    unf: undefined,\r\n    nul: null,\r\n    obj: {\r\n        name: '我是一个对象',\r\n        id: 1,\r\n        qwe: {\r\n            a: 1\r\n        }\r\n    },\r\n    arr: [0, 1, 2, {b: 2}],\r\n    date: new Date(0),\r\n    reg: /我是一个正则/ig,\r\n    [Symbol('1')]: 1,\r\n    func() {\r\n        console.log(123)\r\n    }\r\n}\r\n\r\nfunction deepclone(obj,map=new WeakMap()){\r\n    if(obj instanceof Date) return new Date(obj);\r\n    if(obj instanceof RegExp) return new RegExp(obj)\r\n    if(obj==null || typeof obj !='object'){\r\n        return obj\r\n    }\r\n    if(map.has(obj)){\r\n        return map.get(obj)\r\n    }\r\n    let t = new obj.constructor()\r\n    map.set(obj,t)\r\n    let keys=[...Object.getOwnPropertyNames(obj),...Object.getOwnPropertySymbols(obj)]\r\n    for(let key of keys){\r\n        t[key]=deepclone(obj[key],map)\r\n    }\r\n\r\n    return t\r\n}\r\n\r\nlet result=deepclone(testobj)\r\nresult.data=new Date()\r\nconsole.log(result,testobj)\r\n```\r\n## 运行结果\r\n```js\r\n{\r\n  num: 0,\r\n  str: '',\r\n  boolean: true,\r\n  unf: undefined,\r\n  nul: null,\r\n  obj: { name: '我是一个对象', id: 1, qwe: { a: 1 } },\r\n  arr: [ 0, 1, 2, { b: 2 } ],\r\n  date: 1970-01-01T00:00:00.000Z,\r\n  reg: /我是一个正则/gi,\r\n  func: [Function: func],\r\n  data: 2020-08-21T11:30:05.269Z,\r\n  [Symbol(1)]: 1\r\n} {\r\n  num: 0,\r\n  str: '',\r\n  boolean: true,\r\n  unf: undefined,\r\n  nul: null,\r\n  obj: { name: '我是一个对象', id: 1, qwe: { a: 1 } },\r\n  arr: [ 0, 1, 2, { b: 2 } ],\r\n  date: 1970-01-01T00:00:00.000Z,\r\n  reg: /我是一个正则/gi,\r\n  func: [Function: func],\r\n  [Symbol(1)]: 1\r\n}\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/16",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/16/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/16/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/16/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/16",
    "id": 683240191,
    "node_id": "MDU6SXNzdWU2ODMyNDAxOTE=",
    "number": 16,
    "title": "React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-21T03:52:59Z",
    "updated_at": "2020-08-21T03:52:59Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "原问题标题“React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？ ”\r\n\r\n这里的n指的是页面的VDOM节点数，这个不太严谨。如果更严谨一点，我们应该应该假设 变化之前的节点数为m，变化之后的节点数为n。\r\n\r\nReact 和 Vue 做优化的前提是“放弃了最优解“，本质上是一种权衡，有利有弊。\r\n\r\n倘若这个算法用到别的行业，比如医药行业，肯定是不行的，为什么？\r\n\r\nReact 和 Vue 做的假设是：\r\n\r\n检测VDOM的变化只发生在同一层\r\n检测VDOM的变化依赖于用户指定的key\r\n如果变化发生在不同层或者同样的元素用户指定了不同的key或者不同元素用户指定同样的key， React 和 Vue都不会检测到，就会发生莫名其妙的问题。\r\n\r\n但是React 认为， 前端碰到上面的第一种情况概率很小，第二种情况又可以通过提示用户，让用户去解决，因此 这个取舍是值得的。 没有牺牲空间复杂度，却换来了在大多数情况下时间上的巨大提升。 明智的选择！\r\n\r\n## 基本概念\r\n首先大家要有个基本概念。\r\n\r\n其实这是一个典型的最小编辑距离的问题，相关算法有很多，比如Git中 ，提交之前会进行一次对象的diff操作，就是用的这个最小距离编辑算法。\r\n\r\nleetcode 有原题目, 如果想明白这个O(n^3)， 可以先看下这个。\r\n\r\n对于树，我们也是一样的，我们定义三种操作，用来将一棵树转化为另外一棵树：\r\n\r\n删除 删除一个节点，将它的children交给它的父节点\r\n\r\n插入 在children中 插入一个节点\r\n\r\n修改 修改节点的值\r\n\r\n事实上，从一棵树转化为另外一棵树，我们有很多方式，我们要找到最少的。\r\n\r\n直观的方式是用动态规划，通过这种记忆化搜索减少时间复杂度。\r\n\r\n## 算法\r\n由于树是一种递归的数据结构，因此最简单的树的比较算法是递归处理。\r\n\r\n详细描述这个算法可以写一篇很长的论文，这里不赘述。 大家想看代码的，这里有[一份](https://github.com/DatabaseGroup/tree-similarity/tree/develop) 我希望没有吓到你。\r\n\r\n确切地说，树的最小距离编辑算法的时间复杂度是O(n^2m(1+logmn)), 我们假设m 与 n 同阶， 就会变成 O(n^3)。",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/15",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/15/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/15/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/15/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/15",
    "id": 683228357,
    "node_id": "MDU6SXNzdWU2ODMyMjgzNTc=",
    "number": 15,
    "title": "写出以下代码打印结果",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2020-08-21T03:17:42Z",
    "updated_at": "2020-08-21T03:30:56Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "```js\r\nfunction changeObjProperty(o) {\r\n  o.siteUrl = \"http://www.baidu.com\"\r\n  o = new Object()\r\n  o.siteUrl = \"http://www.google.com\"\r\n} \r\nlet webSite = new Object();\r\nchangeObjProperty(webSite);\r\nconsole.log(webSite.siteUrl);\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/14",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/14/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/14/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/14/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/14",
    "id": 683210296,
    "node_id": "MDU6SXNzdWU2ODMyMTAyOTY=",
    "number": 14,
    "title": "输出以下打印结果",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-21T02:23:54Z",
    "updated_at": "2020-08-21T02:23:54Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "```js\r\nfunction Foo() {\r\n    Foo.a = function() {\r\n        console.log(1)\r\n    }\r\n    this.a = function() {\r\n        console.log(2)\r\n    }\r\n}\r\nFoo.prototype.a = function() {\r\n    console.log(3)\r\n}\r\nFoo.a = function() {\r\n    console.log(4)\r\n}\r\nFoo.a();\r\nlet obj = new Foo();\r\nobj.a();\r\nFoo.a();\r\n```\r\n## 解析\r\n```js\r\nfunction Foo() {\r\n    Foo.a = function() {\r\n        console.log(1)\r\n    }\r\n    this.a = function() {\r\n        console.log(2)\r\n    }\r\n}\r\n// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行\r\nFoo.prototype.a = function() {\r\n    console.log(3)\r\n}\r\n// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3\r\nFoo.a = function() {\r\n    console.log(4)\r\n}\r\n// 现在在 Foo 上挂载了直接方法 a ，输出值为 4\r\n\r\nFoo.a();\r\n// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以\r\n// # 输出 4\r\n\r\nlet obj = new Foo();\r\n/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：\r\n1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。\r\n2. 在新对象上挂载直接方法 a ，输出值为 2。\r\n*/\r\n\r\nobj.a();\r\n// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，\r\n// # 输出 2\r\n\r\nFoo.a();\r\n// 构建方法里已经替换了全局 Foo 上的 a 方法，所以\r\n// # 输出 1\r\n\r\n```\r\n\r\n\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/13",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/13/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/13/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/13/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/13",
    "id": 683201861,
    "node_id": "MDU6SXNzdWU2ODMyMDE4NjE=",
    "number": 13,
    "title": "不用加减乘除运算符，求整数的7倍",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-21T01:56:24Z",
    "updated_at": "2020-08-21T01:56:24Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 可以使用三类方式：位运算加法、JS hack、进制转换。实现方式分别如下：\r\n这道题的关键在于不能使用运算符号，那么一个直接的思路就是能不能不用加减乘除实现整数的加减法呢？其实不难，复习一下大学课本里面计算机组成原理，应该能想起来如何实现基本的加减乘除法。这里，我们其实只需要实现一个基本的加法：\r\n|  a  |  b  | a+b | 进位 |\r\n| :-: | :-: | :-: |  :-: |\r\n|  0  |  0  |  0  |  无  |\r\n|  1  |  0  |  1  |  无  |\r\n|  0  |  1  |  1  |  无  |\r\n|  1  |  1  |  0  |  有  |\r\n> 从上面的表可以看出一种实现简单的多位二进制整数加法的算法如下\r\n\r\nm 和 n 是两个二进制整数，求 m+n:\r\n\r\n1. 用与运算求m和n共同为\"1\"的位：m' = m & n\r\n2. 用异或运算求m和n其中一个为\"1\"的位: n' = m ^ n\r\n3. 如果m'不为0，那么将m'左移一位（进位），即 m = m' << 1，即 n = n'，跳回到步骤 1\r\n4. 如果 m'为0，那么n'就是我们要求的结果\r\n\r\n```js\r\n/* -- 位运算 -- */\r\n// 先定义位运算加法\r\nfunction bitAdd(m, n){\r\n    while(m){\r\n        [m, n] = [(m & n) << 1, m ^ n];\r\n    }\r\n    return n;\r\n}\r\n\r\n// 位运算实现方式 1 - 循环累加7次\r\nlet multiply7_bo_1 = (num)=>\r\n{\r\n  let sum = 0,counter = new Array(7); // 得到 [empty × 7]\r\n  while(counter.length){\r\n    sum = bitAdd(sum, num);\r\n    counter.shift();\r\n  }\r\n  return sum;\r\n}\r\n\r\n// 位运算实现方式 2 - 二进制进3位(乘以8)后，加自己的补码(乘以-1)\r\nlet multiply7_bo_2 = (num) => bitAdd(num << 3, -num) ;\r\n\r\n/* -- JS hack -- */\r\n\r\n// hack 方式 1 - 利用 Function 的构造器 & 乘号的字节码\r\nlet multiply7_hack_1 = (num) => \r\n    new Function([\"return \",num,String.fromCharCode(42),\"7\"].join(\"\"))();\r\n\r\n// hack 方式 2 - 利用 eval 执行器 & 乘号的字节码\r\nlet multiply7_hack_2 = (num) => \r\n\t\teval([num,String.fromCharCode(42),\"7\"].join(\"\"));\r\n\r\n// hack 方式 3 - 利用 SetTimeout 的参数 & 乘号的字节码\r\nsetTimeout([\"window.multiply7_hack_3=(num)=>(7\",String.fromCharCode(42),\"num)\"].join(\"\"))\r\n\r\n/* -- 进制转换 -- */\r\n\r\n// 进制转换方式 - 利用 toString 转为七进制整数；然后末尾补0(左移一位)后通过 parseInt 转回十进制\r\nlet multiply7_base7 = \r\n    (num)=>parseInt([num.toString(7),'0'].join(''),7);\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/12",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/12/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/12/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/12/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/12",
    "id": 682724933,
    "node_id": "MDU6SXNzdWU2ODI3MjQ5MzM=",
    "number": 12,
    "title": "修改以下 print 函数，使之输出 0 到 99，或者 99 到 0 ",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-20T13:37:25Z",
    "updated_at": "2020-08-20T13:37:25Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "要求：\r\n\r\n1、只能修改 setTimeout 到 Math.floor(Math.random() * 1000 的代码\r\n\r\n2、不能修改 Math.floor(Math.random() * 1000\r\n\r\n3、不能使用全局变量\r\n```js\r\nfunction print(n){\r\n  setTimeout(() => {\r\n    console.log(n);\r\n  }, Math.floor(Math.random() * 1000));\r\n}\r\nfor(var i = 0; i < 100; i++){\r\n  print(i);\r\n}\r\n```\r\n## 修改后\r\n```js\r\nfunction print(n){\r\n  setTimeout((() => {\r\n    console.log(n)\r\n    return ()=>{}\r\n  }).call(n,[]), Math.floor(Math.random() * 1000));\r\n}\r\nfor(var i = 0; i < 100; i++){\r\n  print(i);\r\n}\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/11",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/11/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/11/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/11/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/11",
    "id": 681495501,
    "node_id": "MDU6SXNzdWU2ODE0OTU1MDE=",
    "number": 11,
    "title": "找出字符串中连续出现最多的字符和个数",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-19T02:16:47Z",
    "updated_at": "2020-08-19T02:16:47Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "- 'abcaakjbb' => {'a':2,'b':2}\r\n- 'abbkejsbcccwqaa' => {'c':3}\r\n注意：是连续字符\r\n```js\r\nfunction getmaxlen(str){\r\n   if(str){\r\n       let matchStr=str.match(/(\\w)\\1*/g);\r\n       let lenArr=matchStr.map(item=>item.length);\r\n       let maxLen=Math.max(...lenArr);\r\n       return matchStr.reduce((res,cur)=>{\r\n                if(cur.length===maxLen){\r\n                  res[cur]=maxLen\r\n                }\r\n                return res\r\n              },{})\r\n   }\r\n   return {}\r\n}\r\ngetmaxlen('abbkejsbcccwqaa')\r\n// => {ccc: 3}\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/10",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/10/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/10/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/10/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/10",
    "id": 681483489,
    "node_id": "MDU6SXNzdWU2ODE0ODM0ODk=",
    "number": 10,
    "title": "隐式类型转换计算",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-19T01:37:04Z",
    "updated_at": "2020-08-19T01:37:04Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# # 求以下运算结果\r\n\r\n1 + \"1\"\r\n\r\n2 * \"2\"\r\n\r\n[1, 2] + [2, 1]\r\n\r\n\"a\" + + \"b\"\r\n\r\n- 1 + \"1\"\r\n> 加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来\r\n\r\n所以值为：“11”\r\n\r\n- 2 * \"2\"\r\n> 乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值\r\n\r\n- [1, 2] + [2, 1]\r\n> Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。\r\n\r\n所以两个数组对象的toString方法相加，值为：\"1,22,1\"\r\n\r\n- \"a\" + + \"b\"\r\n> 后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。\r\n\r\n所以值为：\"aNaN\"",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/9",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/9/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/9/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/9/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/9",
    "id": 678372478,
    "node_id": "MDU6SXNzdWU2NzgzNzI0Nzg=",
    "number": 9,
    "title": "正则位置匹配",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-13T11:43:26Z",
    "updated_at": "2020-08-13T11:43:26Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 正则位置匹配\r\n\r\n相邻是字符之间的位置，比如，下图中箭头所指的地方\r\n![图片](D:\\work\\learndoc\\learnRecord\\image\\regps1.jpg \"位置\")\r\n> 文章来源 https://juejin.im/post/6844903487155732494\r\n## 如何匹配字符位置\r\n``` \r\n ^ $ \\b \\B (?=p) (?!p)\r\n```\r\n>  ^ 与 $ 匹配 开头 与 结尾\r\n\r\n例如把字符串的开头和结尾用\"#\"替换\r\n```js\r\nlet res=\"hello\".replace(/^|$/,'#');\r\nconsole.log(res) \r\n// => \"#hello#\"\r\n```\r\n> 多行匹配\r\n```js\r\nlet res=\"I\\nlove\\njavascript\".replace(/^|$/gm,\"#\")\r\nconsole.log(result)\r\n/*\r\n#I#\r\n#love#\r\n#javascript#\r\n*/\r\n```\r\n> \\b 与 \\B\r\n\r\n\\b是单词的边界，具体就是\\w和\\W之间的位置，也包括\\w和^之间的位置，也包括\\w和$之间的位置\r\n\r\n比如一个文件名是\"[js] lesson_01.mp4\"中的\\b 如下\r\n```js\r\nlet res=\"[js] lesson_01.mp4\".replace(/\\b/g,\"#\")\r\nconsole.log(res)\r\n//=> \"[#js#] #lesson_01#.#mp4#\"\r\n```\r\n> 为什么会这样呢，仔细看\r\n首先，\\w是字符数组[0-9a-zA-Z_]的简写，即\\w是字母数字或者下划线中的任一个字符。\r\n而\\W是排除[^0-9a-zA-Z_]的简写，即\\W是\\w之外的任一个字符 \r\n那上面代码的执行结果 \"[#js#] #lesson_01#.#mp4#\" 是怎么来的呢\r\n\r\n- 第一个\"#\"，两边是\"[\"与\"j\", 是\\W与\\w之间的位置\r\n- 第二个\"#\"，两边是\"s\"与\"]\", 是\\w与\\W之间的位置\r\n- 第三个\"#\"，两边是空格与\"l\", 是\\W与\\w之间的位置\r\n- 第四个\"#\"，两边是\"1\"与\".\", 是\\w与\\W之间的位置\r\n- 同理其它\"#\" 以此类推...\r\n> 依据上面的例子如果把所有的 \\B替换成\"#\" \r\n```js\r\nlet res=\"[js] lesson_01.mp4\".replace(/\\B/g,\"#\")\r\nconsole.log(res)\r\n//=> \"#[j#s]# l#e#s#s#o#n#_#0#1.m#p#4\"\r\n```\r\n\r\n> (?=p) 与 (?!p)\r\n\r\n(?=p), p 是一个子模式，即p前面的位置\r\n\r\n比如(?=l) 表示'l'字符前面的位置，例如\r\n```js\r\nlet res=\"hello\".replace(/(?=l)/g,\"#\")\r\n// => \"he#l#lo\"\r\n```\r\n而 (?!p) 就是 (?=p) 的反义词 例如\r\n```js\r\nlet res=\"hello\".replace(/(?!l)/g,\"#\")\r\n// => \"#h#ell#o#\"\r\n```\r\n二者的学名分别是positive lookahead和negative lookahead。\r\n\r\n中文翻译分别是正向先行断言和负向先行断言。\r\n\r\nES6中，还支持positive lookbehind和negative lookbehind。\r\n\r\n具体是(?<=p)和(?<!p)。也有书上把这四个东西，翻译成环视，\r\n\r\n即看看右边或看看左边。但一般书上，没有很好强调这四者是个位置。\r\n\r\n比如(?=p)，一般都理解成：要求接下来的字符与p匹配，但不能包括p的那些字符。而在本人看来(?=p)就与^一样好理解，就是p前面的那个位置。\r\n\r\n## 位置特性\r\n\r\n对于位置的理解，我们可以理解成空字符\"\"。\r\n\r\n比如\"hello\"字符串等价于如下的形式：\r\n```js\r\n\"hello\" == \"\" + \"h\" + \"\" + \"e\" + \"\" + \"l\" + \"\" + \"l\" + \"o\" + \"\";\r\n```\r\n因此，把/^hello$/写成/^^hello?$/，是没有任何问题的：\r\n```js\r\nvar result = /^^hello?$/.test(\"hello\");\r\nconsole.log(result); \r\n// => true\r\n```\r\n甚至可以写成更复杂的:\r\n```js\r\nvar result = /(?=he)^^he(?=\\w)llo$\\b\\b$/.test(\"hello\");\r\nconsole.log(result); \r\n// => true\r\n```\r\n也就是说字符之间的位置，可以写成多个。\r\n\r\n把位置理解空字符，是对位置非常有效的理解方式。\r\n\r\n## 相关案例\r\n\r\n- 不匹配任何东西的正则\r\n\r\n> /.^/  此正则要求只有一个字符 该字符后面是开头\r\n\r\n- 数字千分位分隔符表示法\r\n\r\n比如 12345678 -> 12,345,678\r\n\r\n需要把相应的位置替换成 \",\"\r\n\r\n> 弄出最后一个逗号 (?=\\d{3}$) 就可以做到\r\n```js\r\nlet res=\"12345678\".replace(/(?=\\d{3}$)/g,',')\r\n// => \"12345,678\"\r\n```\r\n> 弄出所有的逗号 要求后面3个数字一组，也就是\\d{3} 至少出现一次 因此可以使用量词 '+'\r\n```js\r\nlet res='12345678'.replace(/(?=(\\d{3})+$)/g,',')\r\n// => \"12,345,678\"\r\n```\r\n> 其余匹配案例\r\n```js\r\n//以上匹配存在问题\r\nlet res='123456789'.replace(/(?=(\\d{3})+$)/g,',')\r\n// => \",123,456,789\"\r\n\r\n// 因为以上正则仅仅把从结尾向前数，一旦是3的倍数，就把其前面的位置换成 ',' 因此才出现这个问题\r\n// 解决 要求匹配这个位置不能是开头 \r\n\r\n\r\n// 要求这个位置不能是开头怎么办 (?!^)\r\n\r\nlet res='123456789'.replace(/(?!^)(?=(\\d{3})+$)/g,',')\r\n// => \"123,456,789\"\r\n```\r\n> 支持其他转换实现 比如把 \"12345678 123456789\"替换成\"12,345,678 123,456,789\"\r\n> >此时需要修改正则 把里面的开头 ^ 和 $ 结尾 替换成 \\b\r\n```js \r\nlet res=\"12345678 123456789\".replace(/(?!\\b)(?=(\\d{3})+\\b)/g,',')\r\n// => \"12,345,678 123,456,789\"\r\n```\r\n> 其中(?!\\b) 要求当前一个位置，但不是\\b前面的位置，其实(?!\\b) 即 \\B\r\n>> 因此最终正则变成了 /\\B(?=(\\d{3})+\\b)/g\r\n```js\r\nlet res=\"12345678 123456789\".replace(/\\B(?=(\\d{3})+\\b)/g,',')\r\n// => \"12,345,678 123,456,789\"\r\n```\r\n- 验证密码长度问题\r\n\r\n密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。\r\n\r\n此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。\r\n\r\n那么，我们就来挑战一下。看看我们对位置的理解是否深刻。\r\n\r\n> 不考虑\"但必须至少包含2种字符\"这一条件\r\n```js\r\n let reg=/[0-9a-zA-Z]{6,12}$/\r\n```\r\n> 判断是否包含有某一种字符\r\n\r\n假设，要求的必须是数字，此时可以使用 (?=.*[0-9])\r\n```js\r\nlet reg=/(?=.*[0-9])^[0-9a-zA-Z]{6-12}$/\r\n```\r\n> 同时包含具体的两种字符\r\n\r\n比如同时包含数字和小写字母 可以使用 (?=.*[0-9])(?=.*[a-z])\r\n```js\r\nlet reg=/(?=.*[0-9])(?=.*[a-z])^[0-9a-zA-Z]{6,12}$/\r\n```\r\n### 解答\r\n 我们可以把原题变换成下列几种情况之一\r\n 1. 同时包含数字和小写字母\r\n 2. 同时包含数字和大写字母\r\n 3. 同时包含小写字母和大写字母\r\n 4. 同时包含数字、小写字母和大写字母\r\n\r\n以上的4种情况是或的关系(实际上，可以不用第四条)\r\n\r\n先看一下例子\r\n\r\n```js\r\n'study'.replace(/(?=s)/, '#') // #study\r\n'study'.replace(/(?=d)/, '#') // stu#dy\r\n'study'.replace(/(?=^)/, '#') // #study\r\n```\r\n> 我们从而得知，是找到匹配的pattern后之前的位置，重点强调匹配到的是位置。\r\n明白了这个，我们来理解下/(?=pattern)^/，及找到符合pattern的开始位置，并且该位置要在^之前，能在^之前的是什么？思考下。\r\n```js\r\n/^^study/.test('study') // true\r\n```\r\n> 看到这个应该就明白 ^之前的就只能是^，^是个锚点。\r\n```js\r\n/(?=\\d)^/.test('9') // true\r\n/(?=\\d)^/.test('9l') // true\r\n/(?=\\d)^/.test('l9') // false\r\n```\r\n> 我们现在明白 /(?=\\d)^/的意思是以数字开头的字符串。\r\n\r\n到这里我们应该明白 /(?=.*[0-9])^/ 的意思是以任意字符(可以无)加数字开头。说白了就是必须包含数字\r\n```js\r\n/(?=.*[0-9])^/.test('9') // true\r\n/(?=.*[0-9])^/.test('9l') // true\r\n/(?=.*[0-9])^/.test('l9') // true\r\n\r\n```\r\n> 扩展\r\n\r\n```js \r\n1、\r\n`study`.replace(/$/, '#') // study#\r\n`study`.replace(/$(?<=y)/, '#') //study#\r\n`study`.replace(/(?<=d)/, '#') // stud#y\r\n\r\n2、\r\n`study1`.replace(/(?![a-z])/g, '#') //study#1#\r\n`study`.replace(/(?![a-z])/g, '#') //study#\r\n```\r\n最终答案\r\n```js\r\nlet reg=/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z]|(?=.*[a-z])(?=.*[A-Z])))^[0-9A-Za-z]{6,12}$/;\r\nconsole.log( reg.test(\"1234567\") ); // false 全是数字\r\nconsole.log( reg.test(\"abcdef\") ); // false 全是小写字母\r\nconsole.log( reg.test(\"ABCDEFGH\") ); // false 全是大写字母\r\nconsole.log( reg.test(\"ab23C\") ); // false 不足6位\r\nconsole.log( reg.test(\"ABCDEF234\") ); // true 大写字母和数字\r\nconsole.log( reg.test(\"abcdEF234\") ); // true 三者都有\r\n\r\n```\r\n### 另一种解法\r\n“至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。\r\n> 那么要求“不能全部都是数字”，怎么做呢？(?!p)出马！\r\n\r\n (?!p)\r\n```js\r\nlet  reg = /(?!^[0-9]{6,12}$)^[0-9A-Za-z]{6,12}$/;\r\n```\r\n> 三种都不能呢\r\n```js\r\nvar reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;\r\nconsole.log( reg.test(\"1234567\") ); // false 全是数字\r\nconsole.log( reg.test(\"abcdef\") ); // false 全是小写字母\r\nconsole.log( reg.test(\"ABCDEFGH\") ); // false 全是大写字母\r\nconsole.log( reg.test(\"ab23C\") ); // false 不足6位\r\nconsole.log( reg.test(\"ABCDEF234\") ); // true 大写字母和数字\r\nconsole.log( reg.test(\"abcdEF234\") ); // true 三者都有\r\n\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/8",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/8/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/8/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/8/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/8",
    "id": 678371803,
    "node_id": "MDU6SXNzdWU2NzgzNzE4MDM=",
    "number": 8,
    "title": "正则表达式 括号",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-13T11:42:09Z",
    "updated_at": "2020-08-13T11:42:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 正则表达式 括号\r\n文本参考 https://juejin.im/post/6844903487155732494\r\n\r\n内容包括：\r\n\r\n1. 分组和分支结构\r\n2. 捕获分组\r\n3. 反向引用\r\n4. 非捕获分组\r\n5. 相关案例\r\n\r\n## 分组\r\n\r\n/a+/ 匹配连续出现的a ,要匹配连续出现的\"ab\"时，需要使用/(ab)+/\r\n```js\r\nvar regex = /(ab)+/g;\r\nvar string = \"ababa abbb ababab\";\r\nconsole.log( string.match(regex) ); \r\n// => [\"abab\", \"ab\", \"ababab\"]\r\n```\r\n## 分支结构\r\n在多选分支结构(p1|p2) \r\n```js\r\nvar regex = /^I love (JavaScript|Regular Expression)$/;\r\nconsole.log( regex.test(\"I love JavaScript\") );\r\nconsole.log( regex.test(\"I love Regular Expression\") );\r\n// => true\r\n// => true\r\n```\r\n如果去掉正则中的括号，即/^I love JavaScript|Regular Expression$/，匹配字符串是\"I love JavaScript\"和\"Regular Expression\"，当然这不是我们想要的。\r\n## 引用分组\r\n以日期为例。假设格式是yyyy-mm-dd的，我们可以先写一个简单的正则：\r\n```js\r\nvar regex = /\\d{4}-\\d{2}-\\d{2}/;\r\n```\r\n带括号版 可以提取年、月、日\r\n```js\r\nlet regex=/(\\d{4})-(\\d{2})-(\\d{2})/;\r\nlet str=\"2020-08-11\"\r\nconsole.log(str.match(regex))\r\n// => [\"2020-08-11\", \"2020\", \"08\", \"11\", index: 0, input: \"2020-08-11\", groups: undefined]\r\nregex=/(\\d{4})-(\\d{2})-(\\d{2})/g;\r\nconsole.log(str.match(regex))\r\n// => [\"2020-08-11\"]\r\n```\r\nmatch 返回一个数组，第一个元素是整体匹配结果，然后是各个分组(括号里)匹配的内容，然后是下标，最后是输入的文本\r\n> 如果正则是否有修饰符g，match 返回的数组格式是不一样的\r\n\r\n使用正则对象的exec方法\r\n```js\r\nlet regex=/(\\d{4})-(\\d{2})-(\\d{2})/;\r\nlet str=\"2020-08-11\"\r\nconsole.log(regex.exec(str))\r\n// => [\"2020-08-11\", \"2020\", \"08\", \"11\", index: 0, input: \"2020-08-11\", groups: undefined]\r\n```\r\n也可以使用构造函数的全局属性$1-$9来获取\r\n```js\r\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\r\nvar string = \"2017-06-12\";\r\n\r\nregex.test(string); // 正则操作即可，例如\r\n//regex.exec(string);\r\n//string.match(regex);\r\n\r\nconsole.log(RegExp.$1); // \"2017\"\r\nconsole.log(RegExp.$2); // \"06\"\r\nconsole.log(RegExp.$3); // \"12\"\r\n\r\n```\r\n### 替换\r\n比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做\r\n```js\r\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\r\nvar string = \"2017-06-12\";\r\nvar result = string.replace(regex, \"$2/$3/$1\");\r\nconsole.log(result); \r\n// => \"06/12/2017\"\r\n```\r\n其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：\r\n```js\r\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\r\nvar string = \"2017-06-12\";\r\nvar result = string.replace(regex, function(){\r\n    return RegExp.$2+\"/\"+RegExp.$3+\"/\"+RegExp.$1;\r\n});\r\nconsole.log(result); \r\n// => \"06/12/2017\"\r\n```\r\n也可以写成\r\n```js\r\nvar regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\r\nvar string = \"2017-06-12\";\r\nvar result = string.replace(regex, function(match,year,month,day){\r\n    return month+\"/\"+day+\"/\"+year;\r\n});\r\nconsole.log(result); \r\n// => \"06/12/2017\"\r\n```\r\n## 反向引用\r\n除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。\r\n\r\n还是以日期为例。\r\n\r\n比如要写一个正则支持匹配如下三种格式：\r\n> - 2016-06-12 \r\n> - 2016/06/12\r\n> - 2016.06.12\r\n\r\n可能会想到这个正则\r\n```js\r\nvar regex = /\\d{4}(-|\\/|\\.)\\d{2}(-|\\/|\\.)\\d{2}/;\r\nvar string1 = \"2017-06-12\";\r\nvar string2 = \"2017/06/12\";\r\nvar string3 = \"2017.06.12\";\r\nvar string4 = \"2016-06/12\";\r\nconsole.log( regex.test(string1) ); // true\r\nconsole.log( regex.test(string2) ); // true\r\nconsole.log( regex.test(string3) ); // true\r\nconsole.log( regex.test(string4) ); // true\r\n\r\n```\r\n其中/和.需要转义。虽然匹配了要求的情况，但也匹配\"2016-06/12\"这样的数据。\r\n\r\n> 假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：\r\n```js\r\nvar regex = /\\d{4}(-|\\/|\\.)\\d{2}\\1\\d{2}/;\r\nvar string1 = \"2017-06-12\";\r\nvar string2 = \"2017/06/12\";\r\nvar string3 = \"2017.06.12\";\r\nvar string4 = \"2016-06/12\";\r\nconsole.log( regex.test(string1) ); // true\r\nconsole.log( regex.test(string2) ); // true\r\nconsole.log( regex.test(string3) ); // true\r\nconsole.log( regex.test(string4) ); // false\r\n\r\n```\r\n> 注意里面的\\1，表示的引用之前的那个分组(-|\\/|\\.)。不管它匹配到什么（比如-），\\1都匹配那个同样的具体某个字符。\r\n\r\n我们知道了\\1的含义后，那么\\2和\\3的概念也就理解了，即分别指代第二个和第三个分组。\r\n\r\n看到这里，此时，恐怕你会有三个问题。\r\n### 括号嵌套怎么办\r\n以左括号（开括号）为准。比如：\r\n```js\r\nvar regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;\r\nvar string = \"1231231233\";\r\nconsole.log( regex.test(string) ); // true\r\nconsole.log( RegExp.$1 ); // 123\r\nconsole.log( RegExp.$2 ); // 1\r\nconsole.log( RegExp.$3 ); // 23\r\nconsole.log( RegExp.$4 ); // 3\r\n\r\n```\r\n我们可以看看这个正则匹配模式：\r\n1. 第一个字符是数字，比如说1，\r\n2. 第二个字符是数字，比如说2，\r\n3. 第三个字符是数字，比如说3，\r\n4. 接下来的是\\1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是123，\r\n5. 接下来的是\\2，找到第2个开括号，对应的分组，匹配的内容是1，\r\n6. 接下来的是\\3，找到第3个开括号，对应的分组，匹配的内容是23，\r\n7. 最后的是\\4，找到第3个开括号，对应的分组，匹配的内容是3。\r\n\r\n> \\10 表示什么呢 表示第10个分组 还是\\1 和 0 呢  当然是第十个分组了\r\n```js\r\nvar regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/;\r\nvar string = \"123456789# ######\"\r\nconsole.log( regex.test(string) );\r\n// => true\r\n\r\n```\r\n引用不存在的分组会怎样呢\r\n因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错只是匹配反向引用字符本身，例如\\2,就匹配'\\2'。 \r\n> 注意'\\2' 此时表示对\"2\" 进行了转意\r\n```js\r\nar regex = /\\1\\2\\3\\4\\5\\6\\7\\8\\9/;\r\nconsole.log( regex.test(\"\\1\\2\\3\\4\\5\\6\\7\\8\\9\") ); \r\nconsole.log( \"\\1\\2\\3\\4\\5\\6\\7\\8\\9\".split(\"\") );\r\n// =>  [\"\u0001\", \"\u0002\", \"\u0003\", \"\u0004\", \"\u0005\", \"\u0006\", \"\u0007\", \"8\", \"9\"]\r\n```\r\n## 非捕获分组\r\n之前文章中出现的分组，都会捕获他们匹配到的数据，以便后续引用，因此也称他们是捕获型分组\r\n\r\n如果只想要括号最原始的功能，但不会引用它，即不在API里引用，也不在正则里反向引用，此时可以使用非捕获分组(?:p) \r\n```js\r\nvar regex =/(?:ab)+/g;\r\nvar str='ababa abbb ababab';\r\nconsole.log(str.match(regex));\r\n// => [\"abab\", \"ab\", \"ababab\"]\r\n```\r\n\r\n## 相关案例\r\n\r\n### 字符串trim方法模拟\r\n去掉字符串开头和结尾的空白符\r\n-  匹配到开头和结尾的空白符，然后替换成空字符\r\n```js\r\nfunction trim(str){\r\n    return str.replace(/^\\s+|\\s+$/g,'')\r\n}\r\nconsole.log(trim('  hello world  '))\r\n```\r\n- 匹配整个字符串，然后用引用来提取出相应的数据\r\n```js\r\nfunction trim(str){\r\n    return str.replace(/^\\s*(.*?)\\s*$/g,'$1')\r\n}\r\nconsole.log(trim('  hello world  '))\r\n```\r\n> 这里使用了惰性匹配 *? 不然也会匹配最后一个空格之前所有的空格\r\n\r\n前者效率更高一些\r\n\r\n### 将每个单词的首字母转换成大写\r\n```js\r\nfunction titleize(str){\r\n    return str.toLowerCase().replace(/(?:^|\\s)\\w/g,function(c){\r\n        console.log(c)\r\n        return c.toUpperCase()\r\n    })\r\n}\r\nconsole.log(titleize('hello everyone'))\r\n// => Hello Everyone\r\n```\r\n> 思路是找到每个单词的首个字母，当然这里不使用非捕获匹配也是可以的。\r\n\r\n### 驼峰化\r\n```js\r\nfunction camelize(str){\r\n    return str.replace(/[-_\\s]+(.)?/g,function(match,c){\r\n        console.log(c)\r\n        return c?c.toUpperCase():'';\r\n    })\r\n} \r\nconsole.log(camelize('-moz-transform'))\r\n// => MozTransform\r\n```\r\n> 其中分组(.)表示首字母，单词的界定是，前面的字符可以是多个连字符、下划线以及空白符，正则后面的?的目的，是为了应对str尾部的字符可能不是单词字符，比如str是'-moz-transform    '。\r\n### 中划线化\r\n```js\r\nfunction dasherize(str){\r\n    return str.replace(/([A-Z])/g,'-$1').replace(/[-_\\s]+/g,'-').toLowerCase()\r\n}\r\nconsole.log( dasherize('MozTransform') ); \r\n```\r\n驼峰化的逆过程\r\n### HTML转义和反转义\r\n```js\r\n// 将HTML特殊字符转换成等值的实体\r\nfunction escapeHTML(str) {\r\n\tvar escapeChars = {\r\n\t  '¢' : 'cent',\r\n\t  '£' : 'pound',\r\n\t  '¥' : 'yen',\r\n\t  '€': 'euro',\r\n\t  '©' :'copy',\r\n\t  '®' : 'reg',\r\n\t  '<' : 'lt',\r\n\t  '>' : 'gt',\r\n\t  '\"' : 'quot',\r\n\t  '&' : 'amp',\r\n\t  '\\'' : '#39'\r\n\t};\r\n\treturn str.replace(new RegExp('[' + Object.keys(escapeChars).join('') +']', 'g'), function(match) {\r\n        console.log(match)\r\n\t\treturn '&' + escapeChars[match] + ';';\r\n\t});\r\n}\r\nconsole.log( escapeHTML('<div>Blah blah blah</div>') );\r\n// => \"&lt;div&gt;Blah blah blah&lt;/div&gt\";\r\n```\r\n其中使用了构造函数生成的正则，然后替换相应的格式就行了\r\n\r\n它的逆过程，使用了括号，以便提供引用，也很简单\r\n```js\r\n/ 实体字符转换为等值的HTML。\r\nfunction unescapeHTML(str) {\r\n\tvar htmlEntities = {\r\n\t  nbsp: ' ',\r\n\t  cent: '¢',\r\n\t  pound: '£',\r\n\t  yen: '¥',\r\n\t  euro: '€',\r\n\t  copy: '©',\r\n\t  reg: '®',\r\n\t  lt: '<',\r\n\t  gt: '>',\r\n\t  quot: '\"',\r\n\t  amp: '&',\r\n\t  apos: '\\''\r\n\t};\r\n\treturn str.replace(/\\&([^;]+);/g, function(match, key) {\r\n\t\tif (key in htmlEntities) {\r\n\t\t\treturn htmlEntities[key];\r\n\t\t}\r\n\t\treturn match;\r\n\t});\r\n}\r\nconsole.log( unescapeHTML('&lt;div&gt;Blah blah blah&lt;/div&gt;') );\r\n// => \"<div>Blah blah blah</div>\"\r\n```\r\n通过key获取相应的分组引用，然后作为对象的键\r\n### 匹配成对标签\r\n要求匹配\r\n> - \\<title\\>regular expression\\<\\/title\\>\r\n> - \\<p\\>laoyao bye bye\\<\\/p\\>\r\n\r\n不匹配\r\n> \\<title>wrong!\\</p>\r\n\r\n匹配一个开标签，可以使用正则<[^>]+>\r\n\r\n匹配一个闭标签，可以使用<\\/[^>]+>\r\n\r\n但是要求匹配成对标签，那就是要使用反向引用\r\n```js\r\nvar regex=/<([^>]+)>[\\d\\D]*<\\/\\1>/\r\nvar string1 = \"<title>regular expression</title>\";\r\nvar string2 = \"<p>laoyao bye bye</p>\";\r\nvar string3 = \"<title>wrong!</p>\";\r\nconsole.log( regex.test(string1) ); // true\r\nconsole.log( regex.test(string2) ); // true\r\nconsole.log( regex.test(string3) ); // false\r\n\r\n```\r\n其中开标签 <[^>]+> 改成 <([^>]+)> 使用括号的目的是为了后面的反向引用，而提供分组，闭标签使用了反向引用<\\/\\1>\r\n\r\n> 另外 [\\d\\D] 的意思是，这个字符是数字或者不是数字， 因此，也就是匹配任意字符的意思\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/7",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/7/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/7/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/7/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/7",
    "id": 678370598,
    "node_id": "MDU6SXNzdWU2NzgzNzA1OTg=",
    "number": 7,
    "title": "正则字符匹配",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-13T11:39:52Z",
    "updated_at": "2020-08-13T11:39:52Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 正则字符匹配\r\n## 惰性匹配 就是尽可能少的匹配\r\n```js\r\nlet regex = /\\d{2,5}?/g;\r\nlet string = \"123 1234 12345 123456\";\r\nconsole.log( string.match(regex) ); \r\n// => [\"12\", \"12\", \"34\", \"12\", \"34\", \"12\", \"34\", \"56\"]\r\n```\r\n\r\n## 贪婪的，它会尽可能多的匹配\r\n```js\r\nlet regex = /\\d{2,5}/g;\r\nlet string = \"123 1234 12345 123456\";\r\nconsole.log( string.match(regex) ); \r\n// => [\"123\", \"1234\", \"12345\", \"12345\"]\r\n```\r\n\r\n## 多选分支 \r\n\r\n```js\r\n// 例如要匹配\"good\"和\"nice\"可以使用/good|nice/。\r\n// 测试如下：\r\nlet regex = /good|nice/g;\r\nlet string = \"good idea, nice try.\";\r\nconsole.log( string.match(regex) ); \r\n// => [\"good\", \"nice\"]\r\n//但有个事实我们应该注意，比如我用/good|goodbye/，去匹配\"goodbye\"字符串时，\r\n//结果是\"good\"：\r\nlet regex = /good|goodbye/g;\r\nlet string = \"goodbye\";\r\nconsole.log( string.match(regex) ); \r\n// => [\"good\"]\r\n//把正则改成/goodbye|good/，结果是：\r\nlet regex = /goodbye|good/g;\r\nlet string = \"goodbye\";\r\nconsole.log( string.match(regex) ); \r\n// => [\"goodbye\"]\r\n//也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。\r\n```\r\n## 匹配id\r\n### 贪婪匹配的问题\r\n```js\r\n//要求从 <div id=\"container\" class=\"main\"></div> 提取出id=\"container\"\r\n// 最开始想到的正则可能是\r\nlet regex=/id=\".*\"/\r\nlet str=\"<div id=\"container\" class=\"main\"></div>\"\r\nconsole.log(str.match(regex))\r\n//=> id=\"container\" class=\"main\"\r\n// 因为.是通配符，本身就匹配双引号的，而量词*又是贪婪的，当遇到container后面的双引号时，又不会停下来，就会继续匹配，直到遇到最后一个双引号为止\r\n\r\n//\r\n```\r\n### 惰性匹配解决问题\r\n```js\r\nlet regex=/id=\".*?\"/\r\nlet str=\"<div id=\"container\" class=\"main\"></div>\"\r\nconsole.log(str.match(regex))\r\n//=> id=\"container\"\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/6",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/6/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/6/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/6/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/6",
    "id": 676608451,
    "node_id": "MDU6SXNzdWU2NzY2MDg0NTE=",
    "number": 6,
    "title": "vue 计算属性 vs 侦听属性",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-11T06:04:49Z",
    "updated_at": "2020-08-11T06:04:49Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 计算属性 VS 侦听属性\r\n\r\nVue 的组件对象支持了计算属性 computed 和侦听属性 watch 2 个选项，很多同学不了解什么时候该用 computed 什么时候该用 watch。先不回答这个问题，我们接下来从源码实现的角度来分析它们两者有什么区别。\r\n\r\n## computed\r\n---\r\n计算属性的初始化是发生在 Vue 实例初始化阶段的 initState 函数中，执行了 if (opts.computed) initComputed(vm, opts.computed)，initComputed 的定义在 src/core/instance/state.js 中：\r\n```js\r\nconst computedWatcherOptions = { computed: true }\r\nfunction initComputed (vm: Component, computed: Object) {\r\n  // $flow-disable-line\r\n  const watchers = vm._computedWatchers = Object.create(null)\r\n  // computed properties are just getters during SSR\r\n  const isSSR = isServerRendering()\r\n\r\n  for (const key in computed) {\r\n    const userDef = computed[key]\r\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\r\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\r\n      warn(\r\n        `Getter is missing for computed property \"${key}\".`,\r\n        vm\r\n      )\r\n    }\r\n\r\n    if (!isSSR) {\r\n      // create internal watcher for the computed property.\r\n      watchers[key] = new Watcher(\r\n        vm,\r\n        getter || noop,\r\n        noop,\r\n        computedWatcherOptions\r\n      )\r\n    }\r\n\r\n    // component-defined computed properties are already defined on the\r\n    // component prototype. We only need to define computed properties defined\r\n    // at instantiation here.\r\n    if (!(key in vm)) {\r\n      defineComputed(vm, key, userDef)\r\n    } else if (process.env.NODE_ENV !== 'production') {\r\n      if (key in vm.$data) {\r\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\r\n      } else if (vm.$options.props && key in vm.$options.props) {\r\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n函数首先创建 vm._computedWatchers 为一个空对象，接着对 computed 对象做遍历，拿到计算属性的每一个 userDef，然后尝试获取这个 userDef 对应的 getter 函数，拿不到则在开发环境下报警告。接下来为每一个 getter 创建一个 watcher，这个 watcher 和渲染 watcher 有一点很大的不同，它是一个 computed watcher，因为 const computedWatcherOptions = { computed: true }。computed watcher 和普通 watcher 的差别我稍后会介绍。最后对判断如果 key 不是 vm 的属性，则调用 defineComputed(vm, key, userDef)，否则判断计算属性对于的 key 是否已经被 data 或者 prop 所占用，如果是的话则在开发环境报相应的警告。\r\n\r\n那么接下来需要重点关注 defineComputed 的实现：\r\n```js\r\nexport function defineComputed (\r\n  target: any,\r\n  key: string,\r\n  userDef: Object | Function\r\n) {\r\n  const shouldCache = !isServerRendering()\r\n  if (typeof userDef === 'function') {\r\n    sharedPropertyDefinition.get = shouldCache\r\n      ? createComputedGetter(key)\r\n      : userDef\r\n    sharedPropertyDefinition.set = noop\r\n  } else {\r\n    sharedPropertyDefinition.get = userDef.get\r\n      ? shouldCache && userDef.cache !== false\r\n        ? createComputedGetter(key)\r\n        : userDef.get\r\n      : noop\r\n    sharedPropertyDefinition.set = userDef.set\r\n      ? userDef.set\r\n      : noop\r\n  }\r\n  if (process.env.NODE_ENV !== 'production' &&\r\n      sharedPropertyDefinition.set === noop) {\r\n    sharedPropertyDefinition.set = function () {\r\n      warn(\r\n        `Computed property \"${key}\" was assigned to but it has no setter.`,\r\n        this\r\n      )\r\n    }\r\n  }\r\n  Object.defineProperty(target, key, sharedPropertyDefinition)\r\n}\r\n```\r\n这段逻辑很简单，其实就是利用 Object.defineProperty 给计算属性对应的 key 值添加 getter 和 setter，setter 通常是计算属性是一个对象，并且拥有 set 方法的时候才有，否则是一个空函数。在平时的开发场景中，计算属性有 setter 的情况比较少，我们重点关注一下 getter 部分，缓存的配置也先忽略，最终 getter 对应的是 createComputedGetter(key) 的返回值，来看一下它的定义：\r\n```js\r\nfunction createComputedGetter (key) {\r\n  return function computedGetter () {\r\n    const watcher = this._computedWatchers && this._computedWatchers[key]\r\n    if (watcher) {\r\n      watcher.depend()\r\n      return watcher.evaluate()\r\n    }\r\n  }\r\n}\r\n```\r\ncreateComputedGetter 返回一个函数 computedGetter，它就是计算属性对应的 getter。\r\n\r\n整个计算属性的初始化过程到此结束，我们知道计算属性是一个 computed watcher，它和普通的 watcher 有什么区别呢，为了更加直观，接下来来我们来通过一个例子来分析 computed watcher 的实现。\r\n```js\r\nvar vm = new Vue({\r\n  data: {\r\n    firstName: 'Foo',\r\n    lastName: 'Bar'\r\n  },\r\n  computed: {\r\n    fullName: function () {\r\n      return this.firstName + ' ' + this.lastName\r\n    }\r\n  }\r\n})\r\n```\r\n当初始化这个 computed watcher 实例的时候，构造函数部分逻辑稍有不同：\r\n```js\r\nconstructor (\r\n  vm: Component,\r\n  expOrFn: string | Function,\r\n  cb: Function,\r\n  options?: ?Object,\r\n  isRenderWatcher?: boolean\r\n) {\r\n  // ...\r\n  if (this.computed) {\r\n    this.value = undefined\r\n    this.dep = new Dep()\r\n  } else {\r\n    this.value = this.get()\r\n  }\r\n}  \r\n```\r\n可以发现 computed watcher 会并不会立刻求值，同时持有一个 dep 实例。\r\n\r\n然后当我们的 render 函数执行访问到 this.fullName 的时候，就触发了计算属性的 getter，它会拿到计算属性对应的 watcher，然后执行 watcher.depend()，来看一下它的定义：\r\n```js\r\n/**\r\n  * Depend on this watcher. Only for computed property watchers.\r\n  */\r\ndepend () {\r\n  if (this.dep && Dep.target) {\r\n    this.dep.depend()\r\n  }\r\n}\r\n```\r\n注意，这时候的 Dep.target 是渲染 watcher，所以 this.dep.depend() 相当于渲染 watcher 订阅了这个 computed watcher 的变化。\r\n\r\n然后再执行 watcher.evaluate() 去求值，来看一下它的定义：\r\n```js   \r\n/**\r\n  * Evaluate and return the value of the watcher.\r\n  * This only gets called for computed property watchers.\r\n  */\r\nevaluate () {\r\n  if (this.dirty) {\r\n    this.value = this.get()\r\n    this.dirty = false\r\n  }\r\n  return this.value\r\n}\r\n```\r\nevaluate 的逻辑非常简单，判断 this.dirty，如果为 true 则通过 this.get() 求值，然后把 this.dirty 设置为 false。在求值过程中，会执行 value = this.getter.call(vm, vm)，这实际上就是执行了计算属性定义的 getter 函数，在我们这个例子就是执行了 return this.firstName + ' ' + this.lastName。\r\n\r\n这里需要特别注意的是，由于 this.firstName 和 this.lastName 都是响应式对象，这里会触发它们的 getter，根据我们之前的分析，它们会把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候 Dep.target 就是这个 computed watcher。\r\n\r\n最后通过 return this.value 拿到计算属性对应的值。我们知道了计算属性的求值过程，那么接下来看一下它依赖的数据变化后的逻辑。\r\n\r\n一旦我们对计算属性依赖的数据做修改，则会触发 setter 过程，通知所有订阅它变化的 watcher 更新，执行 watcher.update() 方法：\r\n```js\r\n/* istanbul ignore else */\r\nif (this.computed) {\r\n  // A computed property watcher has two modes: lazy and activated.\r\n  // It initializes as lazy by default, and only becomes activated when\r\n  // it is depended on by at least one subscriber, which is typically\r\n  // another computed property or a component's render function.\r\n  if (this.dep.subs.length === 0) {\r\n    // In lazy mode, we don't want to perform computations until necessary,\r\n    // so we simply mark the watcher as dirty. The actual computation is\r\n    // performed just-in-time in this.evaluate() when the computed property\r\n    // is accessed.\r\n    this.dirty = true\r\n  } else {\r\n    // In activated mode, we want to proactively perform the computation\r\n    // but only notify our subscribers when the value has indeed changed.\r\n    this.getAndInvoke(() => {\r\n      this.dep.notify()\r\n    })\r\n  }\r\n} else if (this.sync) {\r\n  this.run()\r\n} else {\r\n  queueWatcher(this)\r\n}\r\n```\r\n那么对于计算属性这样的 computed watcher，它实际上是有 2 种模式，lazy 和 active。如果 this.dep.subs.length === 0 成立，则说明没有人去订阅这个 computed watcher 的变化，仅仅把 this.dirty = true，只有当下次再访问这个计算属性的时候才会重新求值。在我们的场景下，渲染 watcher 订阅了这个 computed watcher 的变化，那么它会执行：\r\n```js\r\nthis.getAndInvoke(() => {\r\n  this.dep.notify()\r\n})\r\n\r\ngetAndInvoke (cb: Function) {\r\n  const value = this.get()\r\n  if (\r\n    value !== this.value ||\r\n    // Deep watchers and watchers on Object/Arrays should fire even\r\n    // when the value is the same, because the value may\r\n    // have mutated.\r\n    isObject(value) ||\r\n    this.deep\r\n  ) {\r\n    // set new value\r\n    const oldValue = this.value\r\n    this.value = value\r\n    this.dirty = false\r\n    if (this.user) {\r\n      try {\r\n        cb.call(this.vm, value, oldValue)\r\n      } catch (e) {\r\n        handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\r\n      }\r\n    } else {\r\n      cb.call(this.vm, value, oldValue)\r\n    }\r\n  }\r\n}\r\n```\r\ngetAndInvoke 函数会重新计算，然后对比新旧值，如果变化了则执行回调函数，那么这里这个回调函数是 this.dep.notify()，在我们这个场景下就是触发了渲染 watcher 重新渲染。\r\n\r\n通过以上的分析，我们知道计算属性本质上就是一个 computed watcher，也了解了它的创建过程和被访问触发 getter 以及依赖更新的过程，其实这是最新的计算属性的实现，之所以这么设计是因为 Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 watcher 重新渲染，本质上是一种优化。\r\n\r\n接下来我们来分析一下侦听属性 watch 是怎么实现的。\r\n\r\n## watch\r\n---\r\n侦听属性的初始化也是发生在 Vue 的实例初始化阶段的 initState 函数中，在 computed 初始化之后，执行了：\r\n```js\r\nif (opts.watch && opts.watch !== nativeWatch) {\r\n  initWatch(vm, opts.watch)\r\n}\r\n```\r\n来看一下 initWatch 的实现，它的定义在 src/core/instance/state.js 中：\r\n```js\r\nfunction initWatch (vm: Component, watch: Object) {\r\n  for (const key in watch) {\r\n    const handler = watch[key]\r\n    if (Array.isArray(handler)) {\r\n      for (let i = 0; i < handler.length; i++) {\r\n        createWatcher(vm, key, handler[i])\r\n      }\r\n    } else {\r\n      createWatcher(vm, key, handler)\r\n    }\r\n  }\r\n}\r\n```\r\n这里就是对 watch 对象做遍历，拿到每一个 handler，因为 Vue 是支持 watch 的同一个 key 对应多个 handler，所以如果 handler 是一个数组，则遍历这个数组，调用 createWatcher 方法，否则直接调用 createWatcher：\r\n```js\r\nfunction createWatcher (\r\n  vm: Component,\r\n  expOrFn: string | Function,\r\n  handler: any,\r\n  options?: Object\r\n) {\r\n  if (isPlainObject(handler)) {\r\n    options = handler\r\n    handler = handler.handler\r\n  }\r\n  if (typeof handler === 'string') {\r\n    handler = vm[handler]\r\n  }\r\n  return vm.$watch(expOrFn, handler, options)\r\n}\r\n```\r\n这里的逻辑也很简单，首先对 hanlder 的类型做判断，拿到它最终的回调函数，最后调用 vm.$watch(keyOrFn, handler, options) 函数，$watch 是 Vue 原型上的方法，它是在执行 stateMixin 的时候定义的：\r\n```js\r\nVue.prototype.$watch = function (\r\n  expOrFn: string | Function,\r\n  cb: any,\r\n  options?: Object\r\n): Function {\r\n  const vm: Component = this\r\n  if (isPlainObject(cb)) {\r\n    return createWatcher(vm, expOrFn, cb, options)\r\n  }\r\n  options = options || {}\r\n  options.user = true\r\n  const watcher = new Watcher(vm, expOrFn, cb, options)\r\n  if (options.immediate) {\r\n    cb.call(vm, watcher.value)\r\n  }\r\n  return function unwatchFn () {\r\n    watcher.teardown()\r\n  }\r\n```\r\n也就是说，侦听属性 watch 最终会调用 $watch 方法，这个方法首先判断 cb 如果是一个对象，则调用 createWatcher 方法，这是因为 $watch 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 const watcher = new Watcher(vm, expOrFn, cb, options) 实例化了一个 watcher，这里需要注意一点这是一个 user watcher，因为 options.user = true。通过实例化 watcher 的方式，一旦我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb，并且如果我们设置了 immediate 为 true，则直接会执行回调函数 cb。最后返回了一个 unwatchFn 方法，它会调用 teardown 方法去移除这个 watcher。\r\n\r\n所以本质上侦听属性也是基于 Watcher 实现的，它是一个 user watcher。其实 Watcher 支持了不同的类型，下面我们梳理一下它有哪些类型以及它们的作用。\r\n\r\n## watcher options\r\n---\r\nWatcher 的构造函数对 options 做的了处理，代码如下：\r\n```js\r\nif (options) {\r\n  this.deep = !!options.deep\r\n  this.user = !!options.user\r\n  this.computed = !!options.computed\r\n  this.sync = !!options.sync\r\n  // ...\r\n} else {\r\n  this.deep = this.user = this.computed = this.sync = false\r\n}\r\n```\r\n所以 watcher 总共有 4 种类型，我们来一一分析它们，看看不同的类型执行的逻辑有哪些差别。\r\n\r\n## deep watcher\r\n通常，如果我们想对一下对象做深度观测的时候，需要设置这个属性为 true，考虑到这种情况：\r\n```js\r\nvar vm = new Vue({\r\n  data() {\r\n    a: {\r\n      b: 1\r\n    }\r\n  },\r\n  watch: {\r\n    a: {\r\n      handler(newVal) {\r\n        console.log(newVal)\r\n      }\r\n    }\r\n  }\r\n})\r\nvm.a.b = 2\r\n```\r\n这个时候是不会 log 任何数据的，因为我们是 watch 了 a 对象，只触发了 a 的 getter，并没有触发 a.b 的 getter，所以并没有订阅它的变化，导致我们对 vm.a.b = 2 赋值的时候，虽然触发了 setter，但没有可通知的对象，所以也并不会触发 watch 的回调函数了。\r\n\r\n而我们只需要对代码做稍稍修改，就可以观测到这个变化了\r\n```js\r\nwatch: {\r\n  a: {\r\n    deep: true,\r\n    handler(newVal) {\r\n      console.log(newVal)\r\n    }\r\n  }\r\n}\r\n```\r\n这样就创建了一个 deep watcher 了，在 watcher 执行 get 求值的过程中有一段逻辑：\r\n```js\r\nget() {\r\n  let value = this.getter.call(vm, vm)\r\n  // ...\r\n  if (this.deep) {\r\n    traverse(value)\r\n  }\r\n}\r\n```\r\n在对 watch 的表达式或者函数求值后，会调用 traverse 函数，它的定义在 src/core/observer/traverse.js 中：\r\n```js\r\nimport { _Set as Set, isObject } from '../util/index'\r\nimport type { SimpleSet } from '../util/index'\r\nimport VNode from '../vdom/vnode'\r\n\r\nconst seenObjects = new Set()\r\n\r\n/**\r\n * Recursively traverse an object to evoke all converted\r\n * getters, so that every nested property inside the object\r\n * is collected as a \"deep\" dependency.\r\n */\r\nexport function traverse (val: any) {\r\n  _traverse(val, seenObjects)\r\n  seenObjects.clear()\r\n}\r\n\r\nfunction _traverse (val: any, seen: SimpleSet) {\r\n  let i, keys\r\n  const isA = Array.isArray(val)\r\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\r\n    return\r\n  }\r\n  if (val.__ob__) {\r\n    const depId = val.__ob__.dep.id\r\n    if (seen.has(depId)) {\r\n      return\r\n    }\r\n    seen.add(depId)\r\n  }\r\n  if (isA) {\r\n    i = val.length\r\n    while (i--) _traverse(val[i], seen)\r\n  } else {\r\n    keys = Object.keys(val)\r\n    i = keys.length\r\n    while (i--) _traverse(val[keys[i]], seen)\r\n  }\r\n}\r\n```\r\ntraverse 的逻辑也很简单，它实际上就是对一个对象做深层递归遍历，因为遍历过程中就是对一个子对象的访问，会触发它们的 getter 过程，这样就可以收集到依赖，也就是订阅它们变化的 watcher，这个函数实现还有一个小的优化，遍历过程中会把子响应式对象通过它们的 dep id 记录到 seenObjects，避免以后重复访问。\r\n\r\n那么在执行了 traverse 后，我们再对 watch 的对象内部任何一个值做修改，也会调用 watcher 的回调函数了。\r\n\r\n对 deep watcher 的理解非常重要，今后工作中如果大家观测了一个复杂对象，并且会改变对象内部深层某个值的时候也希望触发回调，一定要设置 deep 为 true，但是因为设置了 deep 后会执行 traverse 函数，会有一定的性能开销，所以一定要根据应用场景权衡是否要开启这个配置。\r\n## user watcher\r\n前面我们分析过，通过 vm.$watch 创建的 watcher 是一个 user watcher，其实它的功能很简单，在对 watcher 求值以及在执行回调函数的时候，会处理一下错误，如下：\r\n```js\r\nget() {\r\n  if (this.user) {\r\n    handleError(e, vm, `getter for watcher \"${this.expression}\"`)\r\n  } else {\r\n    throw e\r\n  }\r\n},\r\ngetAndInvoke() {\r\n  // ...\r\n  if (this.user) {\r\n    try {\r\n      this.cb.call(this.vm, value, oldValue)\r\n    } catch (e) {\r\n      handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\r\n    }\r\n  } else {\r\n    this.cb.call(this.vm, value, oldValue)\r\n  }\r\n}\r\n```\r\nhandleError 在 Vue 中是一个错误捕获并且暴露给用户的一个利器\r\n## computed watcher\r\ncomputed watcher 几乎就是为计算属性量身定制的，我们刚才已经对它做了详细的分析，这里不再赘述了。\r\n## sync watcher\r\n在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。\r\n```js\r\nupdate () {\r\n  if (this.computed) {\r\n    // ...\r\n  } else if (this.sync) {\r\n    this.run()\r\n  } else {\r\n    queueWatcher(this)\r\n  }\r\n}\r\n```\r\n只有当我们需要 watch 的值的变化到执行 watcher 的回调函数是一个同步过程的时候才会去设置该属性为 true。\r\n\r\n# 总结\r\n通过这一小节的分析我们对计算属性和侦听属性的实现有了深入的了解，计算属性本质上是 computed watcher，而侦听属性本质上是 user watcher。就应用场景而言，计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。\r\n\r\n同时我们又了解了 watcher 的 4 个 options，通常我们会在创建 user watcher 的时候配置 deep 和 sync，可以根据不同的场景做相应的配置。",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/5",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/5/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/5/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/5/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/5",
    "id": 602606071,
    "node_id": "MDU6SXNzdWU2MDI2MDYwNzE=",
    "number": 5,
    "title": "三数求和",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-04-19T03:01:20Z",
    "updated_at": "2020-04-19T03:01:20Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": ">真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\r\n注意：答案中不可以包含重复的三元组。\r\n\r\n>示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\r\n## 思路分析\r\n三数之和延续两数之和的思路，我们可以把求和问题变成求差问题——固定其中一个数，在剩下的数中寻找是否有两个数和这个固定数相加是等于0的。\r\n双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。因此这道题的第一步是将数组排序\r\n然后，对数组进行遍历，每次遍历到哪个数字，就固定哪个数字。然后把左指针指向该数字后面一个坑里的数字，把右指针指向数组末尾，让左右指针从起点开始，向中间前进：\r\n\r\n![image](https://user-images.githubusercontent.com/24433701/79678202-723c9900-822b-11ea-9f84-6b8aa95bb179.png)\r\n每次指针移动一次位置，就计算一下两个指针指向数字之和加上固定的那个数之后，是否等于0。如果是，那么我们就得到了一个目标组合；否则，分两种情况来看：\r\n相加之和大于0，说明右侧的数偏大了，右指针左移\r\n相加之和小于0，说明左侧的数偏小了，左指针右移\r\ntips：这个数组在题目中要求了“不重复的三元组”，因此我们还需要做一个重复元素的跳过处理。这一点在编码实现环节大家会注意到。\r\n\r\n## 编码实现\r\n```javascript\r\nlet numSum=[-1, 0, 1, 2, -1, -4]\r\nlet sum=0\r\n\r\nfunction numSumArr(arr,sum){\r\n    let result=[],len=arr.length;\r\n    arr=arr.sort((a,b)=>a-b)\r\n    for(let i=0;i<len-2;i++){\r\n        let j=i+1,k=len-1;\r\n        if(i>0 && arr[i]==arr[i-1]){\r\n            continue\r\n        }\r\n        while (j<k) {\r\n            if(arr[i]+arr[j]+arr[k]<sum){\r\n                j++\r\n                while (j<k && arr[j]==arr[j-1]) {\r\n                    j++\r\n                }\r\n            }else if (arr[i]+arr[j]+arr[k]>sum) {\r\n                k--\r\n                while(j<k && arr[k]==arr[k+1]){\r\n                    k--\r\n                }\r\n            }else{\r\n                result.push([arr[i],arr[j],arr[k]])\r\n                j++\r\n                k--\r\n                while (j<k && arr[j]==arr[j-1]) {\r\n                    j++\r\n                }\r\n                while (j<k && arr[k]==arr[k+1]) {\r\n                    k--\r\n                }\r\n            }\r\n        }\r\n    }\r\n    console.log('result',result)\r\n    return result\r\n}\r\n\r\nnumSumArr(numSum,0)\r\n```\r\n\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/4",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/4/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/4/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/4/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/4",
    "id": 602587351,
    "node_id": "MDU6SXNzdWU2MDI1ODczNTE=",
    "number": 4,
    "title": "合并两个有序数组",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-04-19T00:49:45Z",
    "updated_at": "2020-04-19T00:49:45Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "```\r\n给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。\r\n说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。\r\n```\r\n```\r\n示例: 输入:\r\nnums1 = [1,3,5,7], m = 4\r\nnums2 =[2,4,6,7,12,16], n = 6\r\n输出: [ 1, 2, 3, 4, 5, 6, 7, 7, 12, 16 ]\r\n```\r\n## 解题思路，双指针法\r\n初始化nums1的空间为m+n-1\r\nnums1的初始索引为m-1\r\nnums2的初始索引为n-1\r\n分别比较指针所指向的数值大小,并将大的数值放到nums1的尾部，指针做对应的-1\r\n\r\n```javascript\r\n/**\r\n * \r\n * @param {number[]} arr1 \r\n * @param {number} m \r\n * @param {number[]} arr2 \r\n * @param {number} n \r\n */\r\nfunction merge(arr1,m,arr2,n) {\r\n    let i=m-1,j=n-1,k=m+n-1;\r\n    while (i>=0 && j>=0) {\r\n        if(arr1[i]>arr2[j]){\r\n            arr1[k]=arr1[i]\r\n            i--\r\n            k--\r\n        }else{\r\n            arr1[k]=arr2[j]\r\n            j--\r\n            k--\r\n        }\r\n    }\r\n    while(j>=0){\r\n        arr1[k]=arr2[j]\r\n        j--\r\n        k--\r\n    }\r\n}\r\nlet nums1=[1,3,5,7]\r\nlet nums2=[2,4,6,7,12,16]\r\nmerge(nums1,4,nums2,6)\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/3",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/3/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/3/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/3/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/3",
    "id": 581518964,
    "node_id": "MDU6SXNzdWU1ODE1MTg5NjQ=",
    "number": 3,
    "title": "链表",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 3,
    "created_at": "2020-03-15T05:04:49Z",
    "updated_at": "2020-03-15T10:41:50Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "### 链表与数组的区别\r\n- 数组的大小是固定的，从数组的起点或者中间插入、移除项的成本很高（需要移动其他元素）；链表在添加、移除元素的时候不需要移动其他元素。\r\n- 链表存储有序的元素集合，元素在内存中并不是连续放置的，每个元素都由一个存储本身的节点和指向下一个 节点元素的引用；数组在内存中元素是连续放置的。\r\n- 数组可以直接访问任何位置的元素，数组元素的访问时间复杂度为**O(1)**；链表需要从头（表头）开始迭代列表直到找到所需的元素，链表元素的访问时间复杂度为**O(N)**。",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/2",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/2/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/2/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/2/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/2",
    "id": 581226059,
    "node_id": "MDU6SXNzdWU1ODEyMjYwNTk=",
    "number": 2,
    "title": "队列实现",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2020-03-14T14:14:27Z",
    "updated_at": "2020-03-14T16:14:16Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "### 实现队列，具有以下功能\r\n- enqueue : 向队尾添加一个（或几个）新元素\r\n- dequeue : 移除队列中第一个的元素，同时返回被移除的元素\r\n- front : 返回队列中第一个元素，不对队列做任何修改\r\n- isEmpty : 如果队列里没有任何元素返回true，否则返回false\r\n- size: 返回队列中元素个数\r\n- print : 把队列中存放的元素打印出来\r\n### ES5 实现队列\r\n```javascript\r\nfunction Queue() {\r\n    let items=[]\r\n    this.enqueue=function (item) {\r\n        items.push(item)\r\n    }\r\n    this.dequeue=function () {\r\n        return items.shift()\r\n    }\r\n    this.front=function(){\r\n        return items[0]\r\n    }\r\n    this.isEmpty=function(){\r\n        return items.length==0\r\n    }\r\n    this.size=function(){\r\n        return items.length\r\n    }\r\n    this.print=function(){\r\n        console.log(items.toString())\r\n    }\r\n}\r\n```\r\n### ES6 实现\r\n```javascript\r\nlet Queue=(function () {\r\n    let items=new WeakMap()\r\n    class Queue{\r\n        constructor(){\r\n            items.set(this,[])\r\n        }\r\n        enqueue(item){\r\n            let arr=items.get(this)\r\n            arr.push(item)\r\n        }\r\n        dequeue(){\r\n            let arr=items.get(this)\r\n            return arr.shift()\r\n        }\r\n        front(){\r\n            let arr=items.get(this)\r\n            return arr[0]\r\n        }\r\n        isEmpty(){\r\n            let arr=items.get(this)\r\n            return arr.length==0\r\n        }\r\n        size(){\r\n            let arr=items.get(this)\r\n            return arr.length\r\n        }\r\n        print(){\r\n            let arr=items.get(this)\r\n            console.log(arr.toString())\r\n        }\r\n    }\r\n    return Queue\r\n})()\r\n\r\n```",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/1",
    "repository_url": "https://api.github.com/repos/guyuezhai/interviewSummary",
    "labels_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/1/labels{/name}",
    "comments_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/1/comments",
    "events_url": "https://api.github.com/repos/guyuezhai/interviewSummary/issues/1/events",
    "html_url": "https://github.com/guyuezhai/interviewSummary/issues/1",
    "id": 581202770,
    "node_id": "MDU6SXNzdWU1ODEyMDI3NzA=",
    "number": 1,
    "title": "栈的实现",
    "user": {
      "login": "guyuezhai",
      "id": 24433701,
      "node_id": "MDQ6VXNlcjI0NDMzNzAx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24433701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guyuezhai",
      "html_url": "https://github.com/guyuezhai",
      "followers_url": "https://api.github.com/users/guyuezhai/followers",
      "following_url": "https://api.github.com/users/guyuezhai/following{/other_user}",
      "gists_url": "https://api.github.com/users/guyuezhai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guyuezhai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guyuezhai/subscriptions",
      "organizations_url": "https://api.github.com/users/guyuezhai/orgs",
      "repos_url": "https://api.github.com/users/guyuezhai/repos",
      "events_url": "https://api.github.com/users/guyuezhai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guyuezhai/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-03-14T13:07:59Z",
    "updated_at": "2020-03-14T13:19:56Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "### 实现栈，具有以下功能\r\n- push : 添加一个（或几个）新元素到栈顶\r\n- pop : 移除栈顶的元素，同时返回被移除的元素\r\n- peek : 返回栈顶元素，不对栈做任何修改\r\n- isEmpty : 如果栈里没有任何元素返回true，否则返回false\r\n- clear : 清空栈中元素\r\n- size: 返回栈中元素个数\r\n- print : 把栈中存放的元素打印出来\r\n\r\n### ES5实现方式\r\n```javascript\r\nfunction Stack(){\r\n    let items=[]\r\n    this.push=function(item){\r\n        items.push(item)\r\n    }\r\n    this.pop=function () {\r\n        return items.pop()\r\n    }\r\n    this.peek=function () {\r\n        return items[items.length-1]\r\n    }\r\n    this.clear=function(){\r\n        items=[]\r\n    }\r\n    this.print=function () {\r\n        console.log(items.toString())\r\n    }\r\n    this.size=function(){\r\n        return items.length()\r\n    }\r\n    this.isEmpty=function(){\r\n        return items.length==0\r\n    }\r\n\r\n}\r\n```\r\n### ES6 实现\r\n```javascript\r\nclass Stack{\r\n    constructor(){\r\n        this.items=[]\r\n    }\r\n    push(item){\r\n        this.items.push(item)\r\n    }\r\n    pop(){\r\n        return this.items.pop()\r\n    }\r\n    peek(){\r\n        let length=this.items.length\r\n        return this.items[length-1]\r\n    }\r\n    isEmpty(){\r\n        return this.items.length==0\r\n    }\r\n    clear(){\r\n        this.items=[]\r\n    }\r\n    size(){\r\n        return this.items.length\r\n    }\r\n    print(){\r\n        console.log(this.items.toString())\r\n    }\r\n}\r\n```",
    "performed_via_github_app": null
  }
]
export default data
